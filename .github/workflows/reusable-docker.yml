# =============================================================================
# REUSABLE WORKFLOW: Docker Build and Security Scanning
# PURPOSE: Build Docker images and scan for vulnerabilities with Trivy
# USAGE: Called by PR and main workflows for container validation
# OUTPUTS: Security findings uploaded to GitHub Security tab, Docker image artifact
# =============================================================================

name: Reusable Docker

on:
  workflow_call:
    inputs:
      platforms:
        description: 'Docker platforms to build (e.g., linux/amd64,linux/arm64)'
        type: string
        default: 'linux/amd64' # Single platform for PRs, multi for main
      push-image:
        description: 'Whether to push image to registry (always false for this workflow)'
        type: boolean
        default: false
      save-artifact:
        description: 'Whether to save Docker image as artifact for later use'
        type: boolean
        default: false
      artifact-name:
        description: 'Name for the Docker image artifact'
        type: string
        default: 'docker-image'
      version:
        description: 'Version tag for the Docker image'
        type: string
        default: ''
      image-name:
        description: 'Docker image name (without registry)'
        type: string
        default: 'sonarqube-mcp-server'
      tag_sha:
        description: 'SHA of the version tag for consistent naming'
        type: string
        default: ''
      build_artifact:
        description: 'Name of the pre-built TypeScript artifact to use'
        type: string
        default: ''
    outputs:
      image-digest:
        description: 'Docker image digest'
        value: ${{ jobs.docker.outputs.digest }}
      artifact-name:
        description: 'Name of the saved artifact'
        value: ${{ jobs.docker.outputs.artifact-name }}

# SECURITY: Required permissions for Docker operations
# Note: packages: write is only needed if pushing to GitHub Container Registry
# Calling workflows can omit it if not pushing images
permissions:
  contents: read # Read source code
  security-events: write # Upload Trivy scan results

jobs:
  docker:
    runs-on: ubuntu-latest
    outputs:
      digest: ${{ steps.build.outputs.digest }}
      artifact-name: ${{ inputs.artifact-name }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifact
        # Download pre-built TypeScript if artifact name provided
        if: inputs.build_artifact != ''
        uses: actions/download-artifact@v4
        with:
          name: ${{ inputs.build_artifact }}

      # =============================================================================
      # DOCKER SETUP
      # Configure build environment for single or multi-platform builds
      # =============================================================================

      - name: Set up QEMU
        # Required for multi-platform builds (arm64)
        if: contains(inputs.platforms, 'arm64')
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        # Advanced Docker builder with cache support
        uses: docker/setup-buildx-action@v3

      # =============================================================================
      # DOCKER BUILD
      # Build image with layer caching for efficiency
      # =============================================================================

      - name: Generate Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ inputs.image-name }}
          tags: |
            type=raw,value=${{ inputs.version }},enable=${{ inputs.version != '' }}
            type=raw,value=latest,enable=${{ inputs.version != '' }}
            type=ref,event=pr
            type=sha,format=short

      - name: Determine build configuration
        # Set clear variables for build mode to improve readability
        id: build-config
        run: |
          # Determine if we're building for multiple platforms
          if echo "${{ inputs.platforms }}" | grep -q ','; then
            echo "is_multi_platform=true" >> $GITHUB_OUTPUT
          else
            echo "is_multi_platform=false" >> $GITHUB_OUTPUT
          fi

          # Determine if we can load the image (only for single-platform non-artifact builds)
          SAVE_ARTIFACT="${{ inputs.save-artifact }}"
          if [ "$SAVE_ARTIFACT" != "true" ] && ! echo "${{ inputs.platforms }}" | grep -q ','; then
            echo "can_load=true" >> $GITHUB_OUTPUT
            echo "output_type=" >> $GITHUB_OUTPUT
          else
            # Need to output to tar for artifact or multi-platform builds
            echo "can_load=false" >> $GITHUB_OUTPUT
            # Use tag SHA if provided, otherwise use github.sha
            SHA_TO_USE="${{ inputs.tag_sha || github.sha }}"
            # Use OCI format for multi-platform builds (docker format doesn't support manifest lists)
            if echo "${{ inputs.platforms }}" | grep -q ','; then
              echo "output_type=type=oci,dest=${{ inputs.artifact-name }}-${SHA_TO_USE}.tar" >> $GITHUB_OUTPUT
            else
              echo "output_type=type=docker,dest=${{ inputs.artifact-name }}-${SHA_TO_USE}.tar" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Build Docker image
        id: build
        uses: docker/build-push-action@v6
        with:
          context: .
          platforms: ${{ inputs.platforms }}
          push: false # Never push from this reusable workflow
          load: ${{ steps.build-config.outputs.can_load == 'true' }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha # Use GitHub Actions cache
          cache-to: type=gha,mode=max # Maximum cache retention
          build-args: |
            VERSION=${{ inputs.version || github.sha }}
          outputs: ${{ steps.build-config.outputs.output_type }}

      # =============================================================================
      # SECURITY SCANNING
      # Trivy vulnerability scanning with configurable severity
      # =============================================================================

      - name: Determine Trivy scan configuration
        # Set clear variables for scan inputs to improve readability
        id: scan-config
        run: |
          # Determine scanning mode based on build configuration
          CAN_LOAD="${{ steps.build-config.outputs.can_load }}"
          if [ "$CAN_LOAD" = "true" ]; then
            # For loaded single-platform images, scan by image reference
            FIRST_TAG=$(echo "${{ steps.meta.outputs.tags }}" | head -n1)
            echo "scan_input=" >> $GITHUB_OUTPUT
            echo "scan_image_ref=$FIRST_TAG" >> $GITHUB_OUTPUT
            echo "Using image reference for scanning: $FIRST_TAG"
          else
            # For multi-platform or artifact builds, scan the tar file
            SHA_TO_USE="${{ inputs.tag_sha || github.sha }}"
            echo "scan_input=${{ inputs.artifact-name }}-${SHA_TO_USE}.tar" >> $GITHUB_OUTPUT
            echo "scan_image_ref=" >> $GITHUB_OUTPUT
            echo "Using tar file for scanning: ${{ inputs.artifact-name }}-${SHA_TO_USE}.tar"
          fi

      - name: Run Trivy vulnerability scanner
        # SECURITY: Scan image for vulnerabilities before any distribution
        # NOTE: Multi-platform OCI exports cannot be scanned from tar files
        # Scans for vulnerabilities, secrets, misconfigurations, and licenses
        # License findings are informational only (see LICENSES.md)
        if: steps.build-config.outputs.can_load == 'true' || !contains(inputs.platforms, ',')
        uses: aquasecurity/trivy-action@0.28.0
        with:
          input: ${{ steps.scan-config.outputs.scan_input }}
          image-ref: ${{ steps.scan-config.outputs.scan_image_ref }}
          exit-code: '1' # Don't fail on license findings - they're documented
          format: 'sarif'
          hide-progress: false
          output: 'trivy-results.sarif'
          severity: 'HIGH,CRITICAL'
          scanners: 'vuln,secret,misconfig'
          ignore-unfixed: true # Only report vulnerabilities with available fixes
          trivyignores: '.trivyignore'
          version: 'latest'
          license-full: true
        env:
          TRIVY_DEBUG: 'true'

      - name: Check Trivy results for vulnerabilities
        # Fail build if non-license security issues are found
        # License findings are informational and don't fail the build
        if: steps.build-config.outputs.can_load == 'true' || !contains(inputs.platforms, ',')
        run: |
          if [ -f trivy-results.sarif ]; then
            # Check for vulnerabilities, secrets, or misconfigurations (not licenses)
            SECURITY_ISSUES=$(jq -r '.runs[0].results[] | select(.ruleId | startswith("CVE-") or startswith("SECRET-") or startswith("CONFIG-")) | .level' trivy-results.sarif 2>/dev/null | wc -l || echo "0")
            if [ "$SECURITY_ISSUES" -gt 0 ]; then
              echo "::error::Found $SECURITY_ISSUES security issue(s) in container image"
              echo "Review the scan results in the Security tab after SARIF upload"
              exit 1
            fi
            echo "No security vulnerabilities found (license findings are informational)"
          fi

      - name: Upload Trivy results to GitHub Security
        # Always upload results, even if scan fails
        # Results viewable at: Security > Code scanning alerts
        if: always() && (steps.build-config.outputs.can_load == 'true' || !contains(inputs.platforms, ','))
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results.sarif'
          category: 'container-scan-${{ github.event_name }}'

      - name: Upload Trivy SARIF as artifact
        # Upload SARIF file as artifact for debugging and inspection
        if: always() && (steps.build-config.outputs.can_load == 'true' || !contains(inputs.platforms, ','))
        uses: actions/upload-artifact@v4
        with:
          name: trivy-${{ github.sha }}
          path: trivy-results.sarif
          retention-days: 7

      # =============================================================================
      # ARTIFACT STORAGE
      # Save Docker image for reuse in publish workflow
      # =============================================================================

      - name: Compress Docker image artifact
        # Compress the tar file to reduce storage costs
        if: inputs.save-artifact
        run: |
          SHA_TO_USE="${{ inputs.tag_sha || github.sha }}"
          echo "Compressing Docker image artifact..."
          gzip -9 ${{ inputs.artifact-name }}-${SHA_TO_USE}.tar
          ls -lh ${{ inputs.artifact-name }}-${SHA_TO_USE}.tar.gz

      - name: Upload Docker image artifact
        # Store image for deterministic publishing
        if: inputs.save-artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ inputs.artifact-name }}-${{ inputs.tag_sha || github.sha }}
          path: ${{ inputs.artifact-name }}-${{ inputs.tag_sha || github.sha }}.tar.gz
          retention-days: 7 # Keep for a week (enough for release cycle)
          compression-level: 0 # Already compressed with gzip

      # =============================================================================
      # SUPPLY CHAIN SECURITY
      # Generate attestations for build provenance (main builds only)
      # =============================================================================

      - name: Generate attestations
        # Creates cryptographic proof of build provenance (SLSA Level 3)
        # Only runs when id-token permission is available (required for attestations)
        if: inputs.save-artifact && inputs.version != '' && env.ACTIONS_ID_TOKEN_REQUEST_URL != ''
        uses: actions/attest-build-provenance@v2
        with:
          subject-path: ${{ inputs.artifact-name }}-${{ inputs.tag_sha || github.sha }}.tar.gz
