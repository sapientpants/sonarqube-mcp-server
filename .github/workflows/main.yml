# =============================================================================
# WORKFLOW: Main Branch Release Pipeline
# PURPOSE: Automate version management, releases, and security scanning on main
# TRIGGERS: Push to main branch (merges, direct commits)
# OUTPUTS: GitHub release with artifacts, NPM package, Docker image
# =============================================================================

name: Main

on:
  push:
    branches: [main]

# Prevent concurrent runs on the same ref to avoid race conditions during releases
# cancel-in-progress: false ensures releases complete even if new commits arrive
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

# SECURITY: Required permissions for release automation
# contents: write - Create releases and tags
# id-token: write - Generate SLSA attestations for supply chain security
# attestations: write - Attach attestations to artifacts
# security-events: write - Upload security scan results
# actions: read - Access workflow runs and artifacts
permissions:
  contents: write
  id-token: write
  attestations: write
  security-events: write
  actions: read

jobs:
  # =============================================================================
  # VALIDATION PHASE
  # Runs all quality checks in parallel to ensure code meets standards
  # =============================================================================

  validate:
    # Reusable workflow handles: audit, typecheck, lint, format, tests
    # FAILS IF: Any check fails, tests don't meet 80% coverage threshold
    uses: ./.github/workflows/reusable-validate.yml
    secrets:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  # =============================================================================
  # SECURITY SCANNING PHASE
  # Parallel security scans to identify vulnerabilities before release
  # =============================================================================

  # CodeQL: Static analysis for security vulnerabilities
  # Scans TypeScript/JavaScript for common security issues (XSS, SQL injection, etc.)
  codeql:
    uses: ./.github/workflows/reusable-security.yml
    with:
      generate-sbom: false # SBOM generated during release for consistency
      run-osv-scan: false # OSV scan runs separately below
      run-codeql: true # Enable CodeQL analysis

  # OSV (Open Source Vulnerabilities) scanning
  # Uses Google's official action for comprehensive dependency vulnerability checks
  # UPDATE: Quarterly review for new scanner versions (currently v2.2.1)
  vulnerability:
    uses: google/osv-scanner-action/.github/workflows/osv-scanner-reusable.yml@v2.2.1
    with:
      # Scan entire project including all manifests (package.json, pnpm-lock.yaml)
      scan-args: |-
        ./
    permissions:
      security-events: write # Required to upload findings to Security tab
      actions: read
      contents: read

  # =============================================================================
  # VERSION DETERMINATION PHASE
  # Determines version and builds artifacts, but doesn't create release yet
  # =============================================================================

  version:
    # Only runs after all validation and security checks pass
    # Determines version number needed for Docker builds
    needs: [validate, codeql, vulnerability]
    runs-on: ubuntu-latest
    outputs:
      changed: ${{ steps.version.outputs.changed }} # true if version changed
      version: ${{ steps.version.outputs.version }} # semantic version number
      commit_sha: ${{ steps.commit.outputs.sha }} # commit SHA for artifact naming
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history needed for changeset detection
          # SECURITY: Use RELEASE_TOKEN if available for protected branch pushes
          # Falls back to GITHUB_TOKEN for standard permissions
          token: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}

      # =============================================================================
      # ENVIRONMENT SETUP
      # Consistent toolchain setup matching package.json requirements
      # =============================================================================

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.17.0 # Pinned: Must match packageManager in package.json
          run_install: false # Dependencies installed separately for caching
          standalone: true # Faster installation method

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22 # Pinned: Must match engines.node in package.json
          cache: pnpm # Cache dependencies between runs (saves 1-2 min)

      - name: Install dependencies
        # frozen-lockfile ensures exact versions from pnpm-lock.yaml
        # FAILS IF: Lock file doesn't match package.json
        run: pnpm install --frozen-lockfile

      # =============================================================================
      # BUILD FOR CHANGESET
      # Build TypeScript to ensure custom changelog generator is available
      # =============================================================================

      - name: Build for changeset
        # Must build before versioning since custom changelog is TypeScript
        # The compiled JS file is needed at: ./dist/src/dev/changelog-custom.js
        run: pnpm build

      # =============================================================================
      # VERSION MANAGEMENT
      # Determines if release needed based on changesets
      # =============================================================================

      - name: Version packages
        id: version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Custom script validates changesets and updates version
          # FAILS IF: feat/fix commits exist without changesets
          # Outputs: changed=true/false, version=X.Y.Z
          # Debug: Add --verbose flag to script for detailed logs
          node .github/scripts/version-and-release.js

      # =============================================================================
      # BUILD AND ARTIFACT GENERATION
      # Only runs when version changes detected
      # =============================================================================

      - name: Build
        # Skip build if no version change (e.g., docs-only commits)
        # Clean and rebuild to ensure SBOM reflects exact build artifacts
        if: steps.version.outputs.changed == 'true'
        run: |
          pnpm clean  # Remove any previous build artifacts
          pnpm build  # Fresh build for release

      - name: Generate SBOM
        # Software Bill of Materials for supply chain security
        # Creates sbom.cdx.json in CycloneDX format
        if: steps.version.outputs.changed == 'true'
        run: pnpm sbom

      - name: Store commit SHA
        # Store the commit SHA for Docker artifact naming
        id: commit
        if: steps.version.outputs.changed == 'true'
        run: |
          echo "sha=${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "ðŸ“Œ Commit SHA for artifacts: ${{ github.sha }}"

  # =============================================================================
  # PREPARE RELEASE ASSETS PHASE
  # Centralized job for preparing all release artifacts (Docker, binaries, etc.)
  # =============================================================================

  prepare-release-assets:
    # Always runs when version changes to prepare any configured assets
    # Handles conditional asset building internally
    needs: [version]
    if: needs.version.outputs.changed == 'true'
    uses: ./.github/workflows/reusable-prepare-assets.yml
    with:
      version: ${{ needs.version.outputs.version }}
      enable_docker: ${{ vars.ENABLE_DOCKER_RELEASE == 'true' }}
      docker_platforms: 'linux/amd64,linux/arm64'
      enable_npm: ${{ vars.ENABLE_NPM_RELEASE == 'true' }}
      # Future: Add more asset configuration parameters here

  # =============================================================================
  # VERSION COMMIT PHASE
  # Commits version changes after all assets are successfully prepared
  # =============================================================================

  commit-version:
    name: Commit Version Changes
    # Only runs after all assets are successfully prepared
    needs: [prepare-release-assets]
    runs-on: ubuntu-latest
    outputs:
      version: ${{ needs.prepare-release-assets.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Install pnpm
        # Required for updating package.json version
        uses: pnpm/action-setup@v4
        with:
          version: 10.17.0
          run_install: false
          standalone: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: pnpm

      - name: Install dependencies
        # Needed for changeset to update versions
        run: pnpm install --frozen-lockfile

      - name: Build for changeset
        # Must build before versioning since custom changelog is TypeScript
        run: pnpm build

      # =============================================================================
      # GIT OPERATIONS
      # =============================================================================

      - name: Install actionlint for pre-commit validation
        run: |
          echo "Installing actionlint for pre-commit validation..."
          bash <(curl https://raw.githubusercontent.com/rhysd/actionlint/main/scripts/download-actionlint.bash)
          echo "${PWD}" >> $GITHUB_PATH

      - name: Update version in package files
        run: |
          # Run changeset version to update package.json and CHANGELOG.md
          # This uses the changesets that were consumed during version determination
          node .github/scripts/version-and-release.js --update-only

      - name: Commit version changes
        run: |
          # Configure git with GitHub Actions bot identity
          git config --local user.email "${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com"
          git config --local user.name "${{ github.actor }}"

          # Stage version-related changes
          git add package.json CHANGELOG.md .changeset

          # Commit with [skip actions] to prevent workflow recursion
          git commit -m "chore(release): v${{ needs.prepare-release-assets.outputs.version }} [skip actions]"

          # Create annotated tag for the release
          git tag -a "v${{ needs.prepare-release-assets.outputs.version }}" -m "Release v${{ needs.prepare-release-assets.outputs.version }}"

          # Push changes and tags to origin
          git push origin main --follow-tags

          echo "âœ… Version changes committed and pushed"

  # =============================================================================
  # GITHUB RELEASE CREATION PHASE
  # Creates GitHub release as the final step after version is committed
  # =============================================================================

  create-release:
    name: Create GitHub Release
    # Only runs after version is committed
    needs: [commit-version, prepare-release-assets]
    runs-on: ubuntu-latest
    outputs:
      released: ${{ steps.release.outputs.released }}
      version: ${{ needs.prepare-release-assets.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # Checkout the newly created tag
          ref: v${{ needs.prepare-release-assets.outputs.version }}

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.17.0
          run_install: false
          standalone: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: pnpm

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build
        # Build to generate the dist files for attestation
        run: |
          pnpm clean
          pnpm build

      - name: Generate SBOM
        run: pnpm sbom

      - name: Create release artifacts
        run: |
          VERSION="${{ needs.prepare-release-assets.outputs.version }}"
          tar -czf dist-${VERSION}.tar.gz dist/
          zip -r dist-${VERSION}.zip dist/

      - name: Extract release notes
        run: |
          VERSION="${{ needs.prepare-release-assets.outputs.version }}"
          awk -v version="## $VERSION" '
            $0 ~ version { flag=1; next }
            /^## [0-9]/ && flag { exit }
            flag { print }
          ' CHANGELOG.md > release-notes.md

          if [ ! -s release-notes.md ]; then
            echo "Release v$VERSION" > release-notes.md
          fi

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.prepare-release-assets.outputs.version }}
          name: v${{ needs.prepare-release-assets.outputs.version }}
          body_path: release-notes.md
          draft: false
          prerelease: false
          make_latest: true
          files: |
            sbom.cdx.json
            dist-${{ needs.prepare-release-assets.outputs.version }}.tar.gz
            dist-${{ needs.prepare-release-assets.outputs.version }}.zip
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}

      # =============================================================================
      # SUPPLY CHAIN SECURITY
      # =============================================================================

      - name: Generate attestations
        # Generate SLSA provenance attestations for supply chain security
        # Requires id-token: write permission
        if: env.ACTIONS_ID_TOKEN_REQUEST_URL != ''
        uses: actions/attest-build-provenance@v2
        with:
          subject-path: |
            dist/**/*.js
            sbom.cdx.json
            dist-*.tar.gz
            dist-*.zip

      - name: Set release output
        id: release
        run: |
          echo "released=true" >> $GITHUB_OUTPUT
          echo "âœ… Released version ${{ needs.prepare-release-assets.outputs.version }}"
