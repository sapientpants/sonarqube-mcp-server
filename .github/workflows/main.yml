# =============================================================================
# WORKFLOW: Main Branch Release Pipeline
# PURPOSE: Automate version management, releases, and security scanning on main
# TRIGGERS: Push to main branch (merges, direct commits)
# OUTPUTS: GitHub release with artifacts, NPM package, Docker image
# =============================================================================

name: Main

on:
  push:
    branches: [main]

# Prevent concurrent runs on the same ref to avoid race conditions during releases
# cancel-in-progress: false ensures releases complete even if new commits arrive
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false

# SECURITY: Required permissions for release automation
# contents: write - Create releases and tags
# id-token: write - Generate SLSA attestations for supply chain security
# attestations: write - Attach attestations to artifacts
# security-events: write - Upload security scan results
# actions: read - Access workflow runs and artifacts
permissions:
  contents: write
  id-token: write
  attestations: write
  security-events: write
  actions: read

jobs:
  # =============================================================================
  # VALIDATION PHASE
  # Runs all quality checks in parallel to ensure code meets standards
  # =============================================================================

  validate:
    # Reusable workflow handles: audit, typecheck, lint, format, tests
    # FAILS IF: Any check fails, tests don't meet 80% coverage threshold
    uses: ./.github/workflows/reusable-validate.yml
    secrets:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  # =============================================================================
  # SECURITY SCANNING PHASE
  # Parallel security scans to identify vulnerabilities before release
  # =============================================================================

  # CodeQL: Static analysis for security vulnerabilities
  # Scans TypeScript/JavaScript for common security issues (XSS, SQL injection, etc.)
  codeql:
    uses: ./.github/workflows/reusable-security.yml
    with:
      generate-sbom: false # SBOM generated during release for consistency
      run-osv-scan: false # OSV scan runs separately below
      run-codeql: true # Enable CodeQL analysis

  # OSV (Open Source Vulnerabilities) scanning
  # Uses Google's official action for comprehensive dependency vulnerability checks
  # UPDATE: Quarterly review for new scanner versions (currently v2.2.1)
  vulnerability:
    uses: google/osv-scanner-action/.github/workflows/osv-scanner-reusable.yml@v2.2.1
    with:
      # Scan entire project including all manifests (package.json, pnpm-lock.yaml)
      scan-args: |-
        ./
    permissions:
      security-events: write # Required to upload findings to Security tab
      actions: read
      contents: read

  # =============================================================================
  # UNIFIED BUILD PHASE
  # Single build job that creates artifacts to be reused throughout the workflow
  # =============================================================================

  build-once:
    name: Build TypeScript Once
    # Runs after validation passes
    needs: [validate, codeql, vulnerability]
    runs-on: ubuntu-latest
    outputs:
      artifact-name: dist-${{ github.sha }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.17.0
          run_install: false
          standalone: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: pnpm

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build TypeScript
        run: |
          pnpm clean
          pnpm build
          echo "âœ… Built TypeScript once for entire workflow"

      - name: Generate artifact manifest
        run: |
          # Create a manifest of what's been built
          cat > build-manifest.json <<EOF
          {
              "build_sha": "${{ github.sha }}",
              "build_time": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
              "node_version": "$(node --version)",
              "pnpm_version": "$(pnpm --version)",
              "typescript_version": "$(pnpm list typescript --json | jq -r '.dependencies.typescript.version')",
              "files": $(find dist -type f -name "*.js" | jq -R . | jq -s .)
          }
          EOF
          echo "ðŸ“‹ Generated build manifest with $(find dist -type f -name "*.js" | wc -l) JavaScript files"

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: dist-${{ github.sha }}
          path: |
            dist/
            package.json
            pnpm-lock.yaml
            build-manifest.json
          retention-days: 1 # Only needed for this workflow run

  # =============================================================================
  # VERSION DETERMINATION PHASE
  # Determines version and creates tag BEFORE building release artifacts
  # =============================================================================

  version:
    # Now depends on build-once to have compiled code available
    needs: [build-once]
    runs-on: ubuntu-latest
    outputs:
      changed: ${{ steps.version.outputs.changed }} # true if version changed
      version: ${{ steps.version.outputs.version }} # semantic version number
      tag_sha: ${{ steps.tag.outputs.sha }} # SHA of the created tag
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history needed for changeset detection
          # SECURITY: Use RELEASE_TOKEN if available for protected branch pushes
          # Falls back to GITHUB_TOKEN for standard permissions
          token: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}

      # =============================================================================
      # ENVIRONMENT SETUP
      # Consistent toolchain setup matching package.json requirements
      # =============================================================================

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build-once.outputs.artifact-name }}

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.17.0
          run_install: false
          standalone: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: pnpm

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      # =============================================================================
      # VERSION MANAGEMENT
      # Determines if release needed based on changesets
      # =============================================================================

      - name: Version packages
        id: version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Custom script validates changesets and determines version
          # Only checks for version changes, doesn't update files
          # FAILS IF: feat/fix commits exist without changesets
          # Outputs: changed=true/false, version=X.Y.Z
          node .github/scripts/version-and-release.js --check-only

      - name: Create and push tag
        # Create tag BEFORE building artifacts so they're associated with the tag
        id: tag
        if: steps.version.outputs.changed == 'true'
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # Configure git
          git config --local user.email "${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com"
          git config --local user.name "${{ github.actor }}"

          # Create annotated tag
          git tag -a "v${VERSION}" -m "Release v${VERSION}"

          # Push tag to trigger artifact builds with correct SHA
          git push origin "v${VERSION}"

          # Get the tag SHA for artifact naming
          TAG_SHA=$(git rev-list -n 1 "v${VERSION}")
          echo "sha=${TAG_SHA}" >> $GITHUB_OUTPUT
          echo "ðŸ“Œ Tag SHA for artifacts: ${TAG_SHA}"

  # =============================================================================
  # PREPARE RELEASE ASSETS PHASE
  # Centralized job for preparing all release artifacts (Docker, binaries, etc.)
  # =============================================================================

  prepare-release-assets:
    # Builds release artifacts using the tagged commit
    needs: [version, build-once]
    if: needs.version.outputs.changed == 'true'
    uses: ./.github/workflows/reusable-prepare-assets.yml
    with:
      version: ${{ needs.version.outputs.version }}
      tag_sha: ${{ needs.version.outputs.tag_sha }}
      build_artifact: ${{ needs.build-once.outputs.artifact-name }}
      enable_docker: ${{ vars.ENABLE_DOCKER_RELEASE == 'true' }}
      docker_platforms: 'linux/amd64,linux/arm64'
      enable_npm: ${{ vars.ENABLE_NPM_RELEASE == 'true' }}

  # =============================================================================
  # VERSION COMMIT PHASE
  # Commits version changes after all assets are successfully prepared
  # =============================================================================

  commit-version:
    name: Commit Version Changes
    # Only runs after all assets are successfully prepared
    needs: [prepare-release-assets, version, build-once]
    runs-on: ubuntu-latest
    outputs:
      version: ${{ needs.prepare-release-assets.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build-once.outputs.artifact-name }}

      - name: Install pnpm
        # Required for updating package.json version
        uses: pnpm/action-setup@v4
        with:
          version: 10.17.0
          run_install: false
          standalone: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: pnpm

      - name: Install dependencies
        # Needed for changeset to update versions
        run: pnpm install --frozen-lockfile

      # =============================================================================
      # GIT OPERATIONS
      # =============================================================================

      - name: Install actionlint for pre-commit validation
        run: |
          echo "Installing actionlint for pre-commit validation..."
          bash <(curl https://raw.githubusercontent.com/rhysd/actionlint/main/scripts/download-actionlint.bash)
          echo "${PWD}" >> $GITHUB_PATH

      - name: Update version in package files
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Run changeset version to update package.json and CHANGELOG.md
          # This uses the changesets that were consumed during version determination
          node .github/scripts/version-and-release.js --update-only

      - name: Commit version changes
        run: |
          # Configure git with GitHub Actions bot identity
          git config --local user.email "${{ github.actor_id }}+${{ github.actor }}@users.noreply.github.com"
          git config --local user.name "${{ github.actor }}"

          # Stage version-related changes
          git add package.json CHANGELOG.md .changeset

          # Commit with [skip actions] to prevent workflow recursion
          git commit -m "chore(release): v${{ needs.prepare-release-assets.outputs.version }} [skip actions]"

          # Push changes to origin (tag already exists from version job)
          git push origin main

          echo "âœ… Version changes committed and pushed"

  # =============================================================================
  # GITHUB RELEASE CREATION PHASE
  # Creates GitHub release as the final step after version is committed
  # =============================================================================

  create-release:
    name: Create GitHub Release
    # Only runs after version is committed
    needs: [commit-version, prepare-release-assets, build-once, version]
    runs-on: ubuntu-latest
    outputs:
      released: ${{ steps.release.outputs.released }}
      version: ${{ needs.prepare-release-assets.outputs.version }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          # Checkout the newly created tag
          ref: v${{ needs.prepare-release-assets.outputs.version }}

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ needs.build-once.outputs.artifact-name }}

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10.17.0
          run_install: false
          standalone: true

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: pnpm

      - name: Install dependencies
        # Only production dependencies needed
        run: pnpm install --prod --frozen-lockfile

      - name: Generate SBOM
        run: pnpm sbom

      - name: Create release artifacts
        run: |
          VERSION="${{ needs.prepare-release-assets.outputs.version }}"
          TAG_SHA="${{ needs.version.outputs.tag_sha }}"
          tar -czf dist-${VERSION}-${TAG_SHA:0:7}.tar.gz dist/
          zip -r dist-${VERSION}-${TAG_SHA:0:7}.zip dist/

      - name: Extract release notes
        run: |
          VERSION="${{ needs.prepare-release-assets.outputs.version }}"
          awk -v version="## $VERSION" '
            $0 ~ version { flag=1; next }
            /^## [0-9]/ && flag { exit }
            flag { print }
          ' CHANGELOG.md > release-notes.md

          if [ ! -s release-notes.md ]; then
            echo "Release v$VERSION" > release-notes.md
          fi

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.prepare-release-assets.outputs.version }}
          name: v${{ needs.prepare-release-assets.outputs.version }}
          body_path: release-notes.md
          draft: false
          prerelease: false
          make_latest: true
          files: |
            sbom.cdx.json
            dist-${{ needs.prepare-release-assets.outputs.version }}-*.tar.gz
            dist-${{ needs.prepare-release-assets.outputs.version }}-*.zip
        env:
          GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}

      # =============================================================================
      # SUPPLY CHAIN SECURITY
      # =============================================================================

      - name: Generate attestations
        # Generate SLSA provenance attestations for supply chain security
        # Requires id-token: write permission
        if: env.ACTIONS_ID_TOKEN_REQUEST_URL != ''
        uses: actions/attest-build-provenance@v2
        with:
          subject-path: |
            dist/**/*.js
            sbom.cdx.json
            dist-*-*.tar.gz
            dist-*-*.zip

      - name: Set release output
        id: release
        run: |
          echo "released=true" >> $GITHUB_OUTPUT
          echo "âœ… Released version ${{ needs.prepare-release-assets.outputs.version }}"
